<!DOCTYPE html>
<html>
<head>
    <title>Bridge Map</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet core -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- FontAwesome for marker icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <style>
    /* Sidebar modal */
    #bridgeSidebarOverlay {
        display: none;
        position: fixed;
        z-index: 9998;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.3);
    }
    #bridgeSidebar {
        height: 100%;
        width: 350px; /* set to your desired sidebar width */
        position: fixed;
        z-index: 9999;
        top: 0;
        right: 0;
        background-color: #fefefe;
        overflow-x: hidden;
        transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
        box-shadow: -2px 0 6px rgba(0, 0, 0, 0.2);
        transform: translateX(100%); /* hide by default */
    }

    #bridgeSidebar.open {
        transform: translateX(0); /* slide in */
    }

    #modal-body {
        padding: 20px;
    }


    /* BIN label style */
    .bin-label {
        display: inline-block;
        font-size: 12px;
        font-weight: bold;
        white-space: nowrap;
    }

    .label-background {
        display: inline-block;
        padding: 3px 6px;
        border-radius: 3px;
        color: #ffffff; /* White text */
        background-color: rgba(0, 0, 0, 0.7); /* Default dark background */
        white-space: nowrap;
        box-shadow: 1px 1px 4px rgba(0,0,0,0.2);
        line-height: 1;
    }


    /* Searchbar */
    #binSearchWrapper {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 9999;
        background: white;
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
    }
    #binSearchInput {
        width: 160px;
    }


    /* Toggles */
    #panelHeaderWrapper {
        position: absolute;
        top: 60px;
        left: 19px;
        z-index: 9999;
        display: flex;
        gap: 10px;
    }
    .toggle-panel-btn {
        background-color: #ffffff;
        border: 1px solid #ccc;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
    }


    /* Filter Panel */
    #filterPanelWrapper,
    #dueSoonPanelWrapper {
        position: absolute;
        top: 95px;
        left: 19px;
        z-index: 9998;
        max-width: 200px;
    }

    #filterToggleBtn {
        background-color: #ffffff;
        border: 1px solid #ccc;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
    }
    .toggle-btn {
        font-size: 11px;
        margin-left: 8px;
        padding: 2px 6px;
        background: #eee;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
    }
    .filter-group.collapsible .filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .collapse-toggle {
        background: none;
        border: none;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        padding: 0 6px;
        color: #666;
    }
    .filter-group.collapsed label {
        display: none;
    }
    .filter-group .collapsible-content.collapsed {
        display: none !important;
    }
    .filter-group .filter-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }


    /* Main panel style */
    #filterPanel {
        display: none;  /* hidden by default */
        background: white;
        padding: 15px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
        max-height: calc(100vh - 150px);
        overflow-y: auto;
        width: 100%;
    }


    /* Force one checkbox per line */
    #filterPanel label {
        display: block;
        margin: 2px 0;
        font-size: 15px;
        white-space: nowrap;
    }

    /* Make sure each filter category container behaves vertically */
    #filterPanel div[id^="filter-"] {
        display: block;
    }

    /* Due Soon Panel */
    #dueSoonPanel {
        display: none;  /* hidden by default */
        background: white;
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
        width: 380px;
    }

    .due-soon-input {
        display: inline-block;
        white-space: nowrap;
    }

    .due-soon-controls {
        display: inline-flex;
        margin-left: 10px;
        float: right;
    }

    #dueSoonPanel input {
        width: 25px;
        margin: 0 1px;
    }

    #dueSoonPanel button {
        width: 50px;
        padding: 1px 0;
        height: 22px;
        line-height: 16px;
        font-size: 12px;
    }

    #dueSoonDays::-webkit-inner-spin-button,
    #dueSoonDays::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }


    /* Map Legend */
    #mapLegend {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 9999;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 15px;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
      line-height: 2.0;
    }

    .legend-box {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 8px;
      border-radius: 50%;
      vertical-align: middle;
    }

    #visibleCounter {
        position: absolute;
        top: 20px;
        left: 215px;
        z-index: 9999;
        background: white;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 15px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
    }

    .collapsible-content {
        display: block;
        margin-left: 0px;
    }

    .collapsible-content.collapsed {
        display: none !important;
    }

    .filter-group {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }

    .filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .collapse-toggle {
        background: none;
        border: none;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        padding: 0 6px;
        color: #666;
    }

    #map {
        height: 100vh;
        width: 100%;
    }

    .sidebar {
        position: fixed;
        right: -400px;
        top: 0;
        width: 400px;
        height: 100%;
        background: white;
        box-shadow: -2px 0 5px rgba(0,0,0,0.2);
        transition: right 0.3s ease;
        z-index: 1000;
    }

    .sidebar.open {
        right: 0;
    }

    .sidebar-content {
        padding: 20px;
        height: 100%;
        overflow-y: auto;
    }

    .custom-marker {
        background: none;
        border: none;
    }

    .toggle-switch {
        display: flex;
        gap: 2px;
        align-items: center;
    }

    .switch-btn {
        font-size: 11px;
        padding: 2px 8px;
        background: #f5f5f5;
        border: 1px solid #ccc;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #666;
    }

    .switch-btn:first-child {
        border-radius: 4px 0 0 4px;
    }

    .switch-btn:nth-child(2) {
        border-radius: 0 4px 4px 0;
        border-left: none;
    }

    .switch-btn.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
    }

    .switch-btn:hover:not(.active) {
        background: #e9ecef;
    }

    .collapse-toggle {
        margin-left: 8px;
    }

    </style>
</head>
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<body>
    <!-- Sidebar Modal -->
    <div id="bridgeSidebarOverlay" onclick="closeModal()"></div>
    <div id="bridgeSidebar" class="sidebar">
        <div class="sidebar-content">
            <div id="modal-body"></div>
        </div>
    </div>

    <!-- Searchbar -->
    <div id="binSearchWrapper">
        <input type="text" id="binSearchInput" placeholder="Search BIN..." list="binList" />
        <datalist id="binList"></datalist>
    </div>

    <div id="visibleCounter">Visible Bridges: 0</div>

    <!-- Filter Panel -->
    <div id="panelHeaderWrapper">
      <button id="filterToggleBtn" class="toggle-panel-btn">ðŸ”½ Filters</button>
      <button id="dueSoonToggleBtn" class="toggle-panel-btn">ðŸ”½ Due Soon</button>
    </div>

    <div id="filterPanelWrapper">
      <div id="filterPanel">

        <!-- Inspection Status -->
        <div id="filter-status" class="filter-group">
          <strong>Inspection Status</strong>
          <label><input type="checkbox" class="filter-checkbox status" value="Assigned" data-group="status" checked> Assigned</label>
          <label><input type="checkbox" class="filter-checkbox status" value="Scheduled" data-group="status" checked> Scheduled</label>
          <label><input type="checkbox" class="filter-checkbox status" value="Inspected" data-group="status" checked> Inspected</label>
        </div>

        <!-- Active Flags -->
        <div class="filter-group">
          <strong>Active Flags</strong>
          <div id="filter-flags"></div>
        </div>

        <!-- Load Posting -->
        <div class="filter-group">
          <strong>Load Posting</strong>
          <div id="filter-posting"></div>
        </div>

        <!-- Special Access -->
        <div class="filter-group">
          <strong>Special Access</strong>
          <div id="filter-access"></div>
        </div>

        <!-- Field Week -->
        <div class="filter-group">
            <div class="filter-header">
                <strong>Field Week</strong>
                <div class="toggle-switch">
                    <button class="switch-btn active" data-group="week" data-action="all">All</button>
                    <button class="switch-btn" data-group="week" data-action="none">None</button>
                    <button class="collapse-toggle" data-target="filter-week-content">+</button>
                </div>
            </div>
            <div id="filter-week-content" class="collapsible-content collapsed">
                <div id="filter-week-items"></div>
            </div>
        </div>

        <!-- Due Month -->
        <div class="filter-group">
            <div class="filter-header">
                <strong>Due Month</strong>
                <div class="toggle-switch">
                    <button class="switch-btn active" data-group="due_month" data-action="all">All</button>
                    <button class="switch-btn" data-group="due_month" data-action="none">None</button>
                    <button class="collapse-toggle" data-target="filter-due_month-content">+</button>
                </div>
            </div>
            <div id="filter-due_month-content" class="collapsible-content collapsed">
                <div id="filter-due_month-items"></div>
            </div>
        </div>
          

      </div>
    </div>

    <!-- Due Soon -->
    <div id="dueSoonPanelWrapper">
        <div id="dueSoonPanel">
            <div class="due-soon-input">
                <label for="dueSoonDays">Show uninspected bridges due in next</label>
                <input type="number" id="dueSoonDays" value="14" min="1" />
                <span>days</span>
            </div>
            <div class="due-soon-controls">
                <button id="applyDueSoon">Apply</button>
            </div>
        </div>
    </div>

    <!-- Legend -->
    <div id="mapLegend">
        <div><span class="legend-box" style="background-color: blue;"></span> Assigned</div>
        <div><span class="legend-box" style="background-color: orange;"></span> Scheduled</div>
        <div><span class="legend-box" style="background-color: green;"></span> Inspected</div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
    <script 
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
    </script>
    <script>
    // Initialize global variables
    let map; 
    let markersGroup;
    let bridgeData = [];  // Add this line
    const binToMarker = {};    
    const allMarkers = [];     
    const socket = io();       // Initialize Socket.IO connection
    let isDueSoonActive = false;

    function createMarkerIcon(color) {
        return L.divIcon({
            className: 'custom-marker',
            html: `
                <svg width="16" height="16" viewBox="0 0 16 16">
                    <circle cx="8" cy="8" r="7" 
                        stroke="#333" 
                        stroke-width="1" 
                        fill="${color}" 
                        fill-opacity="0.9"
                    />
                </svg>
            `,
            iconSize: [16, 16],
            iconAnchor: [8, 8]
        });
    }

    // Add socket connection listener
    socket.on('connect', () => {
        console.log('Connected to server');
    });

    // New bridge event
    socket.on('new_bridge', (newBridge) => {
        console.log('New bridge received:', newBridge);
        
        // Validate coordinates
        if (!newBridge.lat || !newBridge.lon) {
            console.warn(`Bridge ${newBridge.bin} missing coordinates`);
            return;
        }

        // Get status and colors
        const status = getBridgeStatus(newBridge);
        const color = getMarkerColor(status);
        const rgbaColor = color === 'blue' ? 'rgba(0, 0, 255, 0.8)' : 
                          color === 'orange' ? 'rgba(255, 165, 0, 0.8)' : 
                          'rgba(0, 128, 0, 0.8)';

        // Create marker with proper icon
        const marker = L.marker([newBridge.lat, newBridge.lon], {
            icon: createMarkerIcon(color)
        }).addTo(map);

        // Create label
        const label = L.marker([newBridge.lat, newBridge.lon], {
            icon: L.divIcon({
                className: 'bin-label',
                html: `<span class="label-background" style="background-color: ${rgbaColor};">${newBridge.bin}</span>`,
                iconSize: [0, 0],
                iconAnchor: [-10, 8]
            }),
            interactive: false
        }).addTo(map);

        // Add popup
        marker.bindPopup(`
            <span style="font-size:16px;"><b><u>${newBridge.bin}</u></b></span><br>
            <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${newBridge.lat},${newBridge.lon}" target="_blank" style="color:#1976d2;">${newBridge.lat.toFixed(4)}, ${newBridge.lon.toFixed(4)}</a><br>
            <b>New Standards:</b> ${newBridge.stds}<br>
            <b>Due Date:</b> ${newBridge.due}/25<br>
            <b>Active Flags:</b> ${newBridge.flags}<br>
            <b>Load Posting:</b> ${newBridge.posting_label}<br>
            <a href="#" onclick="showModal('${newBridge.bin}'); return false;">See moreâ€¦</a>
        `);

        // Store references
        binToMarker[newBridge.bin] = marker;
        marker.bridgeData = newBridge;
        allMarkers.push({ marker, data: newBridge, label });

        // Add to bridgeData array for filters
        bridgeData.push(newBridge);

        // Force update visibility
        updateBinLabelVisibility();
        updateMarkers();

        console.log(`New bridge ${newBridge.bin} added successfully`);
    });

    // Update your Socket.IO bridge_update handler
    socket.on('bridge_update', (updatedBridge) => {
        console.log('Bridge update received:', updatedBridge);
        const foundMarker = allMarkers.find(m => m.data.bin === updatedBridge.bin);
        if (foundMarker) {
            const { marker, label } = foundMarker;
            
            // Update the bridge data
            foundMarker.data = updatedBridge;
            marker.bridgeData = updatedBridge;

            // Get new status and color
            const status = getBridgeStatus(updatedBridge);
            const color = getMarkerColor(status);
            const rgbaColor = color === 'blue' ? 'rgba(0, 0, 255, 0.8)' : 
                             color === 'orange' ? 'rgba(255, 165, 0, 0.8)' : 
                             'rgba(0, 128, 0, 0.8)'; // green

            // Update marker color
            marker.setIcon(createMarkerIcon(color));

            // Update label color by creating new divIcon
            if (label) {
                label.setIcon(L.divIcon({
                    className: 'bin-label',
                    html: `<span class="label-background" style="background-color: ${rgbaColor};">${updatedBridge.bin}</span>`,
                    iconSize: [0, 0],
                    iconAnchor: [-10, 8]
                }));
            }

            // Update positions if coordinates changed
            if (updatedBridge.lat && updatedBridge.lon) {
                const newLatLng = [updatedBridge.lat, updatedBridge.lon];
                marker.setLatLng(newLatLng);
                if (label) {
                    label.setLatLng(newLatLng);
                }
            }

            // Update popup content
            const popup = `
                <span style="font-size:16px;"><b><u>${updatedBridge.bin}</u></b></span><br>
                <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${updatedBridge.lat},${updatedBridge.lon}" target="_blank" style="color:#1976d2;">${updatedBridge.lat.toFixed(4)}, ${updatedBridge.lon.toFixed(4)}</a><br>
                <b>New Standards:</b> ${updatedBridge.stds}<br>
                <b>Due Date:</b> ${updatedBridge.due}/25<br>
                <b>Active Flags:</b> ${updatedBridge.flags}<br>
                <b>Load Posting:</b> ${updatedBridge.posting_label}<br>
                <a href="#" onclick="showModal('${updatedBridge.bin}'); return false;">See moreâ€¦</a>
            `;

            // Update the popup content
            if (marker.getPopup()) {
                marker.getPopup().setContent(popup);
            }

            // Update sidebar if this bridge is currently shown
            const sidebar = document.getElementById("bridgeSidebar");
            if (sidebar.classList.contains("open")) {
                const currentBin = document.querySelector("#modal-body")?.getAttribute("data-bin");
                if (currentBin === updatedBridge.bin) {
                    showModal(updatedBridge.bin);
                }
            }
        }
    });



    // Replace or update these helper functions
    function getBridgeStatus(bridge) {
        const inspected = bridge.completed && bridge.completed.trim() !== "";
        const scheduled = !inspected && 
            bridge.week && 
            bridge.week.trim() !== "" && 
            bridge.week.trim().toLowerCase() !== "unscheduled";
        
        if (inspected) return "Inspected";
        if (scheduled) return "Scheduled";
        return "Assigned";
    }

    function getMarkerColor(status) {
        switch (status) {
            case "Inspected": return "green";
            case "Scheduled": return "orange";
            case "Assigned": return "blue";
            default: return "blue";
        }
    }
    
    // Initialize filter state object
    const filters = {
        flags: new Set(),
        posting: new Set(),
        access: new Set(),
        week: new Set(),
        due_month: new Set(),
        status: new Set(['Assigned', 'Scheduled', 'Inspected']) // Initialize with all statuses
    };

    // Helper function to get bridge status
    function getBridgeStatus(bridge) {
        const inspected = bridge.completed && bridge.completed.trim() !== "";
        const scheduled = !inspected && 
            bridge.week && 
            bridge.week.trim() !== "" && 
            bridge.week.trim().toLowerCase() !== "unscheduled";
        return inspected ? "Inspected" : scheduled ? "Scheduled" : "Assigned";
    }

    // Helper functions for sorting
    function sortMonths(monthSet) {
        const monthOrder = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];
        return Array.from(monthSet).sort(
            (a, b) => monthOrder.indexOf(a) - monthOrder.indexOf(b)
        );
    }

    function sortWeeks(weekSet) {
        return Array.from(weekSet).sort((a, b) => {
            const dateA = new Date("2025/" + a.replace("Week of ", ""));
            const dateB = new Date("2025/" + b.replace("Week of ", ""));
            return dateA - dateB;
        });
    }

    function pushUnscheduledToEnd(arr) {
        return arr.filter(v => v !== "Unscheduled").concat(
            arr.includes("Unscheduled") ? ["Unscheduled"] : []
        );
    }

    // Function to create filter checkboxes
    function createFilterCheckboxes() {
        const unique = {
            week: new Set(),
            due_month: new Set()
        };

        // Debug: Log some sample due dates first
        console.log("Sample due dates from bridgeData:");
        bridgeData.slice(0, 10).forEach((b, i) => {
            console.log(`Bridge ${i}: BIN=${b.bin}, due="${b.due}", type=${typeof b.due}`);
        });

        // Gather unique values for week and derive due_month from due date
        bridgeData.forEach(b => {
            // Week filtering (if field has data)
            if (b.week != null && b.week !== '') {
                unique.week.add(b.week);
            }
            
            // Due month - extract from due date with multiple format handling
            if (b.due != null && b.due !== '') {
                try {
                    let monthNum = null;
                    const dueStr = String(b.due).trim();
                    
                    console.log(`Processing due date: "${dueStr}" for bridge ${b.bin}`);
                    
                    // Try different date formats
                    if (dueStr.includes('/')) {
                        // Format: "3/15" or "03/15" or "2025-03-15"
                        const parts = dueStr.split('/');
                        if (parts.length >= 2) {
                            monthNum = parseInt(parts[0], 10);
                        }
                    } else if (dueStr.includes('-')) {
                        // Format: "2025-03-15" or "03-15" 
                        const parts = dueStr.split('-');
                        if (parts.length === 3) {
                            // Format: "2025-03-15"
                            monthNum = parseInt(parts[1], 10);
                        } else if (parts.length === 2) {
                            // Format: "03-15"
                            monthNum = parseInt(parts[0], 10);
                        }
                    } else if (dueStr.length >= 4 && !isNaN(dueStr)) {
                        // Format: "0315" (MMDD)
                        monthNum = parseInt(dueStr.substring(0, 2), 10);
                    } else {
                        // Try to parse as a date object
                        const date = new Date(dueStr);
                        if (!isNaN(date.getTime())) {
                            monthNum = date.getMonth() + 1; // getMonth() returns 0-11
                        }
                    }
                    
                    if (monthNum && monthNum >= 1 && monthNum <= 12) {
                        const monthNames = [
                            "January", "February", "March", "April", "May", "June",
                            "July", "August", "September", "October", "November", "December"
                        ];
                        const monthName = monthNames[monthNum - 1];
                        unique.due_month.add(monthName);
                        console.log(`  -> Extracted month: ${monthName} (${monthNum})`);
                    } else {
                        console.log(`  -> Could not extract valid month from "${dueStr}"`);
                    }
                } catch (error) {
                    console.warn(`Error parsing due date for bridge ${b.bin}: ${b.due}`, error);
                }
            }
        });

        console.log("Unique weeks found:", Array.from(unique.week));
        console.log("Unique due months found:", Array.from(unique.due_month));

        // Create Yes/No checkboxes for flags, posting, and access
        createYesNoCheckbox("filter-flags", "flags");
        createYesNoCheckbox("filter-posting", "posting");
        createYesNoCheckbox("filter-access", "access");

        // Create dynamic checkboxes for week and due_month
        createCheckbox("filter-week-items", "week", Array.from(unique.week));
        createCheckbox("filter-due_month-items", "due_month", Array.from(unique.due_month));
    }

    // New function to create Yes/No checkboxes
    function createYesNoCheckbox(containerId, groupKey) {
        const container = document.getElementById(containerId);
        
        // Clear any existing content
        container.innerHTML = "";
        
        // Create Yes checkbox
        const yesLabel = document.createElement("label");
        yesLabel.innerHTML = `
            <input type="checkbox" 
                id="${containerId}-yes" 
                value="Yes" 
                data-group="${groupKey}" 
                checked> Yes`;
        container.appendChild(yesLabel);
        
        // Create No checkbox
        const noLabel = document.createElement("label");
        noLabel.innerHTML = `
            <input type="checkbox" 
                id="${containerId}-no" 
                value="No" 
                data-group="${groupKey}" 
                checked> No`;
        container.appendChild(noLabel);
        
        // Initialize filter set with both values
        filters[groupKey].add("Yes");
        filters[groupKey].add("No");
    }

    // Update the existing createCheckbox function (keep it for week and due_month):
    function createCheckbox(containerId, groupKey, values) {
        const container = document.getElementById(containerId);
        
        // Clear any existing content
        container.innerHTML = "";
        
        // Sort values with custom logic
        let sortedValues = Array.from(values).filter(val => val != null && val !== '');
        
        if (groupKey === 'week') {
            sortedValues = pushUnscheduledToEnd(sortWeeks(values.filter(v => v != null && v !== '')));
        } else if (groupKey === 'due_month') {
            sortedValues = sortMonths(values.filter(v => v != null && v !== ''));
        }

        sortedValues.forEach(val => {
            if (val != null && val !== '') {
                const safeId = `${containerId}-${String(val).replace(/\W+/g, "_")}`;
                const label = document.createElement("label");
                label.innerHTML = `
                    <input type="checkbox" 
                        id="${safeId}" 
                        value="${val}" 
                        data-group="${groupKey}" 
                        checked> ${val}`;
                container.appendChild(label);
                filters[groupKey].add(val);
            }
        });
    }

  
    let explicitlyEmptyFilters = {
        flags: false,
        posting: false,
        access: false,
        week: false,
        due_month: false
    };

    // Update the passesFilters function:
    function passesFilters(bridge) {
        const status = getBridgeStatus(bridge); 
        if (!filters.status.has(status)) return false;

        // Handle Yes/No filters for flags, posting, and access
        const hasFlags = bridge.flags && bridge.flags.trim() !== '';
        const hasPosting = bridge.posting && bridge.posting.trim() !== '';
        const hasAccess = bridge.access && bridge.access.trim() !== '';
        
        const flagsFilter = hasFlags ? "Yes" : "No";
        const postingFilter = hasPosting ? "Yes" : "No";
        const accessFilter = hasAccess ? "Yes" : "No";

        // Handle week filter (direct field comparison)
        const week = bridge.week || '';

        // Handle due_month filter - every bridge has a due date
        let bridgeDueMonth = '';
        if (bridge.due) {
            try {
                let monthNum = null;
                const dueStr = String(bridge.due).trim();
                
                if (dueStr.includes('/')) {
                    const parts = dueStr.split('/');
                    if (parts.length >= 2) {
                        monthNum = parseInt(parts[0], 10);
                    }
                } else if (dueStr.includes('-')) {
                    const parts = dueStr.split('-');
                    if (parts.length === 3) {
                        monthNum = parseInt(parts[1], 10);
                    } else if (parts.length === 2) {
                        monthNum = parseInt(parts[0], 10);
                    }
                } else if (dueStr.length >= 4 && !isNaN(dueStr)) {
                    monthNum = parseInt(dueStr.substring(0, 2), 10);
                } else {
                    const date = new Date(dueStr);
                    if (!isNaN(date.getTime())) {
                        monthNum = date.getMonth() + 1;
                    }
                }
                
                if (monthNum && monthNum >= 1 && monthNum <= 12) {
                    const monthNames = [
                        "January", "February", "March", "April", "May", "June",
                        "July", "August", "September", "October", "November", "December"
                    ];
                    bridgeDueMonth = monthNames[monthNum - 1];
                }
            } catch (error) {
                console.warn(`Error parsing due date for bridge ${bridge.bin}: ${bridge.due}`);
            }
        }

        // FIXED: Check each filter with explicit "none" handling
        if (filters.flags.size > 0 && !filters.flags.has(flagsFilter)) return false;
        if (explicitlyEmptyFilters.flags && filters.flags.size === 0) return false; // Hide all when explicitly set to "none"
        
        if (filters.posting.size > 0 && !filters.posting.has(postingFilter)) return false;
        if (explicitlyEmptyFilters.posting && filters.posting.size === 0) return false;
        
        if (filters.access.size > 0 && !filters.access.has(accessFilter)) return false;
        if (explicitlyEmptyFilters.access && filters.access.size === 0) return false;
        
        if (filters.week.size > 0 && !filters.week.has(week)) return false;
        if (explicitlyEmptyFilters.week && filters.week.size === 0) return false;
        
        if (filters.due_month.size > 0 && !filters.due_month.has(bridgeDueMonth)) return false;
        if (explicitlyEmptyFilters.due_month && filters.due_month.size === 0) return false; // FIXED: Hide all when "None" is clicked

        return true;
    }

    // Update markers based on current filters
    function updateMarkers() {
        if (isDueSoonActive) return; // Don't update if Due Soon is active

        let visibleCount = 0;
        allMarkers.forEach(({ marker, data }) => {
            if (passesFilters(data)) {
                if (!map.hasLayer(marker)) map.addLayer(marker);
                visibleCount++;
            } else {
                if (map.hasLayer(marker)) map.removeLayer(marker);
            }
        });

        document.getElementById("visibleCounter").textContent = 
            `Visible Bridges: ${visibleCount}`;
    }
    
    function updateBinLabelVisibility() {
        if (!map) return;
        const zoom = map.getZoom();
        const showLabels = zoom >= 11;

        allMarkers.forEach(({ marker, label }) => {
            if (label && map.hasLayer(marker)) {
                if (showLabels) {
                    if (!map.hasLayer(label)) map.addLayer(label);
                } else {
                    if (map.hasLayer(label)) map.removeLayer(label);
                }
            } else if (label && map.hasLayer(label)) {
                map.removeLayer(label);
            }
        });
    }

    document.addEventListener("DOMContentLoaded", function () {
        // Initialize map first
        map = L.map('map', {
            maxBounds: [
                [40, -80],  // Southwest coordinates of NY
                [45.5, -71.00000]   // Northeast coordinates of NY
            ],
            maxBoundsViscosity: 0.8,  // Prevents dragging outside of bounds
            minZoom: 8  // Prevents zooming out too far
        }).setView([42.917431, -75.570647], 8);  // Center of NY State
        
        // Initialize markers layer group after map is created
        markersGroup = L.layerGroup().addTo(map);

        map.on('zoomend', updateBinLabelVisibility);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors',
            bounds: [
                [40, -80.5],
                [45.5, -71.5]
            ]
        }).addTo(map);

        // Panel toggle setup
        const filterToggleBtn = document.getElementById("filterToggleBtn");
        const dueSoonToggleBtn = document.getElementById("dueSoonToggleBtn");
        const filterPanel = document.getElementById("filterPanel");
        const dueSoonPanel = document.getElementById("dueSoonPanel");

        // Filter panel toggle
        filterToggleBtn.addEventListener("click", () => {
            if (isDueSoonActive) {
                // Automatically clear the Due Soon filter
                isDueSoonActive = false;
                updateMarkers();
                updateBinLabelVisibility();
                
                // Reset Due Soon panel state
                dueSoonPanel.style.display = "none";
                dueSoonToggleBtn.textContent = "ðŸ”½ Due Soon";
            }

            // Toggle filter panel
            const isVisible = filterPanel.style.display === "block";
            filterPanel.style.display = isVisible ? "none" : "block";
            dueSoonPanel.style.display = "none";
            
            filterToggleBtn.textContent = isVisible ? "ðŸ”½ Filters" : "ðŸ”¼ Filters";
            dueSoonToggleBtn.textContent = "ðŸ”½ Due Soon";
        });

        // Due Soon panel toggle
        dueSoonToggleBtn.addEventListener("click", () => {
            const isVisible = dueSoonPanel.style.display === "block";
            dueSoonPanel.style.display = isVisible ? "none" : "block";
            filterPanel.style.display = "none";
            
            dueSoonToggleBtn.textContent = isVisible ? "ðŸ”½ Due Soon" : "ðŸ”¼ Due Soon";
            filterToggleBtn.textContent = "ðŸ”½ Filters";
        });

        // Collapse toggles for filter groups
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                const targetId = btn.dataset.target;
                const content = document.getElementById(targetId);
                if (!content) {
                    console.error(`Target content not found: ${targetId}`);
                    return;
                }
                
                content.classList.toggle('collapsed');
                btn.textContent = content.classList.contains('collapsed') ? '+' : 'âˆ’';
            });
        });

        // Due Soon Apply button
        document.getElementById("applyDueSoon").addEventListener("click", () => {
            isDueSoonActive = true;
            const days = parseInt(document.getElementById("dueSoonDays").value, 10);
            const today = new Date();

            // Hide all markers first
            allMarkers.forEach(({ marker }) => {
                map.removeLayer(marker);
            });

            // Show only bridges due within the specified days
            allMarkers.forEach(({ marker, data }) => {
                try {
                    const inspected = data.completed && data.completed.trim() !== "";
                    if (inspected) return; // Skip inspected bridges

                    const dueParts = data.due.split("/");
                    const dueDate = new Date(2025, parseInt(dueParts[0]) - 1, parseInt(dueParts[1]));
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));

                    if (diffDays >= 0 && diffDays <= days) {
                        map.addLayer(marker);
                    }
                } catch (error) {
                    console.warn(`Error processing due date for bridge ${data.bin}:`, error);
                }
            });

            // Update visible counter
            const visibleCount = allMarkers.filter(({ marker }) => map.hasLayer(marker)).length;
            document.getElementById("visibleCounter").textContent = 
                `Visible Bridges: ${visibleCount}`;

            // Close the filters panel if it's open
            filterPanel.style.display = "none";
            filterToggleBtn.textContent = "ðŸ”½ Filters";

            updateBinLabelVisibility();
        });

                
        // Fix the fetch call inside DOMContentLoaded
        fetch('/api/bridges')
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json(); // Change from response.json to response.json()
            })
            .then(data => {
                console.log("Received bridge data:", data);
                
                // Store the bridge data globally
                bridgeData = Array.isArray(data) ? data : [];
                
                // Initialize filters after we have the data
                createFilterCheckboxes();
                
                // Process each bridge
                bridgeData.forEach(bridge => {
                    if (!bridge.lat || !bridge.lon) {
                        console.warn(`Bridge ${bridge.bin} missing coordinates`);
                        return;
                    }

                    // Get the bridge status using getBridgeStatus function
                    const status = getBridgeStatus(bridge);

                    const color = getMarkerColor(status);
                    
                    // Create marker with proper color based on status
                    const marker = L.marker([bridge.lat, bridge.lon], {
                        icon: createMarkerIcon(getMarkerColor(status))
                    }).addTo(map);


                    const rgbaColor = color === 'blue' ? 'rgba(0, 0, 255, 0.8)' : 
                                      color === 'orange' ? 'rgba(255, 165, 0, 0.8)' : 
                                      'rgba(0, 128, 0, 0.8)'; // green

                    const label = L.marker([bridge.lat, bridge.lon], {
                        icon: L.divIcon({
                            className: 'bin-label',
                            html: `<span class="label-background" style="background-color: ${rgbaColor};">${bridge.bin}</span>`,
                            iconSize: [0, 0],
                            iconAnchor: [-10, 8]  // Adjust to position label properly
                        }),
                        interactive: false
                    }).addTo(map);

                    // Add popup
                    marker.bindPopup(`
                        <span style="font-size:16px;"><b><u>${bridge.bin}</u></b></span><br>
                        <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${bridge.lat},${bridge.lon}" target="_blank" style="color:#1976d2;">${bridge.lat.toFixed(4)}, ${bridge.lon.toFixed(4)}</a><br>
                        <b>New Standards:</b> ${bridge.stds}<br>
                        <b>Due Date:</b> ${bridge.due}/25<br>
                        <b>Active Flags:</b> ${bridge.flags}<br>
                        <b>Load Posting:</b> ${bridge.posting_label}<br>
                        <a href="#" onclick="showModal('${bridge.bin}'); return false;">See moreâ€¦</a>
                    `);

                    binToMarker[bridge.bin] = marker;
                    marker.bridgeData = bridge;
                    allMarkers.push({ marker, data: bridge, label });
                });

                // Set up filter checkbox event listeners
                document.querySelectorAll("#filterPanel input[type=checkbox]").forEach(cb => {
                    cb.addEventListener("change", () => {
                        const group = cb.dataset.group;
                        const val = cb.value;
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Initialize status filter checkboxes
                document.querySelectorAll('.filter-checkbox.status').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const val = cb.value;
                        const group = 'status'; // explicitly set group for status checkboxes
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Modify the existing filter checkbox event listener to exclude status checkboxes
                document.querySelectorAll("#filterPanel input[type=checkbox]:not(.status)").forEach(cb => {
                    cb.addEventListener("change", () => {
                        const group = cb.dataset.group;
                        const val = cb.value;
                        
                        // Reset explicit empty state when manually checking/unchecking
                        explicitlyEmptyFilters[group] = false;
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        // Update switch button states based on checkbox states
                        updateSwitchButtonStates(group);
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                document.querySelectorAll(".switch-btn").forEach(btn => {
                    btn.addEventListener("click", () => {
                        const group = btn.dataset.group;
                        const action = btn.dataset.action;
                        
                        // Update button states - make clicked button active, others inactive
                        const switchGroup = btn.parentElement;
                        switchGroup.querySelectorAll('.switch-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Get all checkboxes for this group
                        const checkboxes = document.querySelectorAll(
                            `#filter-${group}-content input[type=checkbox], #filter-${group} input[type=checkbox]`
                        );
                        
                        // Clear the filter group
                        filters[group].clear();
                        
                        if (action === 'all') {
                            // Set all checkboxes to checked and add to filters
                            explicitlyEmptyFilters[group] = false;
                            checkboxes.forEach(cb => {
                                cb.checked = true;
                                filters[group].add(cb.value);
                            });
                        } else if (action === 'none') {
                            // Set all checkboxes to unchecked and mark as explicitly empty
                            explicitlyEmptyFilters[group] = true;
                            checkboxes.forEach(cb => {
                                cb.checked = false;
                            });
                        }

                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Add this new function to update switch button states:
                function updateSwitchButtonStates(group) {
                    const checkboxes = document.querySelectorAll(
                        `#filter-${group}-content input[type=checkbox], #filter-${group} input[type=checkbox]`
                    );
                    
                    const switchButtons = document.querySelectorAll(`.switch-btn[data-group="${group}"]`);
                    const allButton = Array.from(switchButtons).find(btn => btn.dataset.action === 'all');
                    const noneButton = Array.from(switchButtons).find(btn => btn.dataset.action === 'none');
                    
                    if (!allButton || !noneButton) return;
                    
                    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                    const noneChecked = Array.from(checkboxes).every(cb => !cb.checked);
                    
                    // Clear all active states first
                    switchButtons.forEach(btn => btn.classList.remove('active'));
                    
                    if (allChecked) {
                        allButton.classList.add('active');
                    } else if (noneChecked) {
                        noneButton.classList.add('active');
                    }
                    // If some are checked and some aren't, no button is active (mixed state)
                }


                // Replace the existing searchbar code inside the fetch .then() callback
                const searchInput = document.getElementById("binSearchInput");
                const searchDatalist = document.getElementById("binList");

                // Clear any existing options
                searchDatalist.innerHTML = "";

                // Add input event for live filtering
                searchInput.addEventListener("input", function() {
                    const value = this.value.trim().toUpperCase();
                    searchDatalist.innerHTML = "";  // Clear existing options

                    if (value.length >= 3) {
                        const matches = bridgeData
                            .filter(b => b.bin.toUpperCase().includes(value))
                            .slice(0, 50);  // Limit to first 50 matches

                        matches.forEach(bridge => {
                            const option = document.createElement("option");
                            option.value = bridge.bin;
                            searchDatalist.appendChild(option);
                        });
                    }
                });

                // Keep the existing keypress handler for Enter key
                searchInput.addEventListener("keypress", function(e) {
                    if (e.key === "Enter") {
                        const value = this.value.trim().toUpperCase();
                        const bridge = bridgeData.find(b => b.bin.toUpperCase() === value);
                        
                        if (bridge) {
                            map.setView([bridge.lat, bridge.lon], 16);
                            const marker = binToMarker[bridge.bin];
                            if (marker) {
                                marker.openPopup();
                            }
                        } else {
                            alert("Bridge not found");
                        }
                        
                        this.value = "";
                    }
                });


                updateLabelVisibility();
                updateMarkers();
            })
            .catch(error => {
                console.error('Error fetching bridge data:', error);
            });



    }); // Close DOMContentLoaded event listener

    // Update the updateLabelVisibility function to use the global map
    function updateLabelVisibility() {
        if (!map) return; // Add safety check
        const currentZoom = map.getZoom();
        const showLabels = currentZoom >= 12;

        document.querySelectorAll('.bin-label').forEach(label => {
            label.style.display = showLabels ? 'block' : 'none';
        });
    }

    // Add this to your JavaScript section
    function showModal(bin) {
        fetch(`/api/bridges/${bin}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(bridge => {
                const modal = document.getElementById('bridgeSidebar');
                const overlay = document.getElementById('bridgeSidebarOverlay');
                const modalBody = document.getElementById('modal-body');
                
                modalBody.setAttribute('data-bin', bridge.bin);
                
                const content = `
                    <h2>Bridge ${bridge.bin}</h2>
                    <p><strong>Region:</strong> ${bridge.region}</p>
                    <p><strong>County:</strong> ${bridge.county}</p>
                    <p><strong>Due Date:</strong> ${bridge.due}/25</p>
                    <p><strong>Completed:</strong> ${bridge.completed || 'Not completed'}</p>
                    <p><strong>Week:</strong> ${bridge.week}</p>
                    <p><strong>Flags:</strong> ${bridge.flags}</p>
                    <p><strong>Flag Info:</strong> ${bridge.flags_info}</p>
                    <p><strong>Posting:</strong> ${bridge.posting}</p>
                    <p><strong>Access:</strong> ${bridge.access}</p>
                    <p><strong>Access Info:</strong> ${bridge.access_info}</p>
                    <p><strong>Special Equipment:</strong> ${bridge.spe}</p>
                    <p><strong>Standards:</strong> ${bridge.stds}</p>
                    <p><strong>Field Time:</strong> ${bridge.field_time}</p>
                `;
                
                modalBody.innerHTML = content;
                modal.classList.add('open');
                overlay.style.display = 'block';
            })
            .catch(error => {
                console.error('Error fetching bridge details:', error);
            });
    }

    // Add this with your other JavaScript functions
    function closeModal() {
        const sidebar = document.getElementById('bridgeSidebar');
        const overlay = document.getElementById('bridgeSidebarOverlay');
        sidebar.classList.remove('open');
        overlay.style.display = 'none';
    }

    // Add this with your other Socket.IO listeners after socket initialization
    socket.on('new_bridge', (newBridge) => {
        console.log('New bridge received:', newBridge);
        
        // Validate coordinates
        if (!newBridge.lat || !newBridge.lon) {
            console.warn(`Bridge ${newBridge.bin} missing coordinates`);
            return;
        }

        // Get status and colors
        const status = getBridgeStatus(newBridge);
        const color = getMarkerColor(status);
        const rgbaColor = color === 'blue' ? 'rgba(0, 0, 255, 0.8)' : 
                          color === 'orange' ? 'rgba(255, 165, 0, 0.8)' : 
                          'rgba(0, 128, 0, 0.8)'; // green
        
        // Create marker with proper icon and add to map immediately
        const marker = L.marker([newBridge.lat, newBridge.lon], {
            icon: createMarkerIcon(color)
        }).addTo(map);

        // Create label with proper styling and add to map immediately
        const label = L.marker([newBridge.lat, newBridge.lon], {
            icon: L.divIcon({
                className: 'bin-label',
                html: `<span class="label-background" style="background-color: ${rgbaColor};">${newBridge.bin}</span>`,
                iconSize: [0, 0],
                iconAnchor: [-10, 8]
            }),
            interactive: false
        }).addTo(map);

        // Add popup
        marker.bindPopup(`
            <span style="font-size:16px;"><b><u>${newBridge.bin}</u></b></span><br>
            <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${newBridge.lat},${newBridge.lon}" target="_blank" style="color:#1976d2;">${newBridge.lat.toFixed(4)}, ${newBridge.lon.toFixed(4)}</a><br>
            <b>New Standards:</b> ${newBridge.stds}<br>
            <b>Due Date:</b> ${newBridge.due}/25<br>
            <b>Active Flags:</b> ${newBridge.flags}<br>
            <b>Load Posting:</b> ${newBridge.posting_label}<br>
            <a href="#" onclick="showModal('${newBridge.bin}'); return false;">See moreâ€¦</a>
        `);

        // Store references
        binToMarker[newBridge.bin] = marker;
        marker.bridgeData = newBridge;
        allMarkers.push({ marker, data: newBridge, label });

        // Add to bridgeData array for filters
        bridgeData.push(newBridge);

        // Force update visibility based on current zoom level
        updateBinLabelVisibility();
        updateMarkers();

        console.log(`New bridge ${newBridge.bin} added successfully`);
    });

    // Add this with your other Socket.IO listeners
    socket.on('bridge_deleted', (data) => {
        console.log('Bridge deleted:', data.bin);
        
        // Find and remove the marker
        const foundMarker = allMarkers.find(m => m.data.bin === data.bin);
        if (foundMarker) {
            // Remove marker
            map.removeLayer(foundMarker.marker);
            // Remove label if it exists
            if (foundMarker.label) {
                map.removeLayer(foundMarker.label);
            }
            // Remove from binToMarker object
            delete binToMarker[data.bin];
            // Remove from allMarkers array
            const index = allMarkers.findIndex(m => m.data.bin === data.bin);
            if (index !== -1) {
                allMarkers.splice(index, 1);
            }
            // Update markers count if you have that functionality
            if (typeof updateMarkers === 'function') {
                updateMarkers();
            }
        }
    });





    </script>

</body>
</html>
