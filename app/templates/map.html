<!DOCTYPE html>
<html>
<head>
    <title>Bridge Map</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet core -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- FontAwesome for marker icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>

    <style>
    /* Sidebar modal */
    #bridgeSidebarOverlay {
        display: none;
        position: fixed;
        z-index: 9998;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.3);
    }
    #bridgeSidebar {
        height: 100%;
        width: 350px; /* set to your desired sidebar width */
        position: fixed;
        z-index: 9999;
        top: 0;
        right: 0;
        background-color: #fefefe;
        overflow-x: hidden;
        transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
        box-shadow: -2px 0 6px rgba(0, 0, 0, 0.2);
        transform: translateX(100%); /* hide by default */
    }

    #bridgeSidebar.open {
        transform: translateX(0); /* slide in */
    }

    #modal-body {
        padding: 20px;
    }
    @media (max-width: 500px) {
        #bridgeSidebar {
            width: 250px;
        }
    }


    /* BIN label style */
    .bin-label {
        font-size: 12px;
        font-weight: bold;
        color: white;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 2px 4px;
        border-radius: 4px;
        text-align: center;
        white-space: nowrap;
        display: none; /* toggled on zoom */
    }


    /* Searchbar */
    #binSearchWrapper {
        position: absolute;
        top: 10px;
        left: 50px;
        z-index: 9999;
        background: white;
        padding: 6px 10px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
    }
    #binSearchInput {
        width: 160px;
    }


    /* Toggles */
    #panelHeaderWrapper {
        position: absolute;
        top: 80px;
        left: 10px;
        z-index: 9999;
        display: flex;
        gap: 10px;
    }
    .toggle-panel-btn {
        background-color: #ffffff;
        border: 1px solid #ccc;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
    }


    /* Filter Panel */
    #filterPanelWrapper,
    #dueSoonPanelWrapper {
        position: absolute;
        top: 115px;
        left: 10px;
        z-index: 9998;
        max-width: 265px;
    }

    #filterToggleBtn {
        background-color: #ffffff;
        border: 1px solid #ccc;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        cursor: pointer;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
    }
    .toggle-btn {
        font-size: 11px;
        margin-left: 8px;
        padding: 2px 6px;
        background: #eee;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
    }
    .filter-group.collapsible .filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .collapse-toggle {
        background: none;
        border: none;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        padding: 0 6px;
        color: #666;
    }
    .filter-group.collapsed label {
        display: none;
    }
    .filter-group .collapsible-content.collapsed {
        display: none !important;
    }
    .filter-group .filter-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
    }


    /* Main panel style */
    #filterPanel {
        display: none;  /* hidden by default */
        background: white;
        padding: 15px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
        max-height: calc(100vh - 150px);
        overflow-y: auto;
        width: 250px;
    }

    /* Always show panel on desktop */
    @media (min-width: 768px) {
    }

    /* Force one checkbox per line */
    #filterPanel label {
        display: block;
        margin: 2px 0;
        font-size: 13px;
        white-space: nowrap;
    }

    /* Make sure each filter category container behaves vertically */
    #filterPanel div[id^="filter-"] {
        display: block;
    }

    /* Due Soon Panel */
    #dueSoonPanel {
        display: none;  /* hidden by default */
        background: white;
        padding: 15px;
        border-radius: 6px;
        box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
        width: 250px;
    }

    #dueSoonPanel input {
        width: 40px;
        margin: 0 5px;
    }

    @media (min-width: 768px) {
    }

    /* Map Legend */
    #mapLegend {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 9999;
      background: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 15px;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.3);
      line-height: 2.0;
    }

    .legend-box {
      display: inline-block;
      width: 16px;
      height: 16px;
      margin-right: 8px;
      border-radius: 50%;
      vertical-align: middle;
    }

    #visibleCounter {
        position: absolute;
        top: 81px;
        left: 210px;
        z-index: 9999;
        background: white;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 13px;
        box-shadow: 0 1px 6px rgba(0,0,0,0.3);
    }

    .collapsible-content {
        display: block;
        margin-left: 15px;
    }

    .collapsible-content.collapsed {
        display: none !important;
    }

    .filter-group {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }

    .filter-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .collapse-toggle {
        background: none;
        border: none;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        padding: 0 6px;
        color: #666;
    }

    #map {
        height: 100vh;
        width: 100%;
    }

    .sidebar {
        position: fixed;
        right: -400px;
        top: 0;
        width: 400px;
        height: 100%;
        background: white;
        box-shadow: -2px 0 5px rgba(0,0,0,0.2);
        transition: right 0.3s ease;
        z-index: 1000;
    }

    .sidebar.open {
        right: 0;
    }

    .sidebar-content {
        padding: 20px;
        height: 100%;
        overflow-y: auto;
    }

    .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 8px 16px;
        background: #f44336;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .close-btn:hover {
        background: #d32f2f;
    }

    .custom-marker {
        background: none;
        border: none;
    }

    </style>
</head>













<body>
    <!-- Sidebar Modal -->
    <div id="bridgeSidebarOverlay" onclick="closeModal()"></div>
    <div id="bridgeSidebar" class="sidebar">
        <div class="sidebar-content">
            <div id="modal-body"></div>
            <button onclick="document.getElementById('bridgeSidebar').classList.remove('open')" class="close-btn">Close</button>
        </div>
    </div>

    <!-- Searchbar -->
    <div id="binSearchWrapper">
        <input type="text" id="binSearchInput" placeholder="Search BIN..." list="binList" />
        <datalist id="binList"></datalist>
    </div>

    <div id="visibleCounter">Visible Bridges: 0</div>

    <!-- Filter Panel -->
    <div id="panelHeaderWrapper">
      <button id="filterToggleBtn" class="toggle-panel-btn">ðŸ”½ Filters</button>
      <button id="dueSoonToggleBtn" class="toggle-panel-btn">ðŸ”½ Due Soon</button>
    </div>

    <div id="filterPanelWrapper">
      <div id="filterPanel">

        <!-- Inspection Status -->
        <div id="filter-status" class="filter-group">
          <strong>Inspection Status</strong>
          <label><input type="checkbox" class="filter-checkbox status" value="Assigned" data-group="status" checked> Assigned</label>
          <label><input type="checkbox" class="filter-checkbox status" value="Scheduled" data-group="status" checked> Scheduled</label>
          <label><input type="checkbox" class="filter-checkbox status" value="Inspected" data-group="status" checked> Inspected</label>
        </div>

        <!-- Active Flags -->
        <div class="filter-group">
          <strong>Active Flags</strong>
          <div id="filter-flags"></div>
        </div>

        <!-- Load Posting -->
        <div class="filter-group">
          <strong>Load Posting</strong>
          <div id="filter-posting"></div>
        </div>

        <!-- Special Access -->
        <div class="filter-group">
          <strong>Special Access</strong>
          <div id="filter-access"></div>
        </div>

        <!-- Field Week -->
        <div class="filter-group">
          <div class="filter-header">
            <strong>Field Week</strong>
            <div>
              <button class="toggle-btn" data-group="week">All / None</button>
              <button class="collapse-toggle" data-target="filter-week-content">+</button>
            </div>
          </div>
          <div id="filter-week-content" class="collapsible-content collapsed">
            <div id="filter-week-items"></div>
          </div>
        </div>
          
        <!-- Due Month -->
        <div class="filter-group">
          <div class="filter-header">
            <strong>Due Month</strong>
            <div>
              <button class="toggle-btn" data-group="due_month">All / None</button>
              <button class="collapse-toggle" data-target="filter-due_month-content">+</button>
            </div>
          </div>
          <div id="filter-due_month-content" class="collapsible-content collapsed">
            <div id="filter-due_month-items"></div>
          </div>
        </div>
          

      </div>
    </div>

    <!-- Due Soon -->
    <div id="dueSoonPanelWrapper">
      <div id="dueSoonPanel">
        <label for="dueSoonDays">Show uninspected bridges due in next</label>
        <input type="number" id="dueSoonDays" value="14" min="1" />
        <span>days</span>
        <button id="applyDueSoon">Apply</button>
        <button id="clearDueSoon">Clear</button>
      </div>
    </div>

    <!-- Legend -->
    <div id="mapLegend">
        <div><span class="legend-box" style="background-color: blue;"></span> Assigned</div>
        <div><span class="legend-box" style="background-color: orange;"></span> Scheduled</div>
        <div><span class="legend-box" style="background-color: green;"></span> Inspected</div>
    </div>

    <!-- Map Container -->
    <div id="map"></div>










    

    <script 
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js">
    </script>
    <script>
    // Initialize global variables
    let map; 
    let markersGroup;
    let bridgeData = [];  // Add this line
    const binToMarker = {};    
    const allMarkers = [];     
    const socket = io();       // Initialize Socket.IO connection
    let isDueSoonActive = false;

    function createMarkerIcon(color) {
        return L.divIcon({
            className: 'custom-marker',
            html: `
                <svg width="16" height="16" viewBox="0 0 16 16">
                    <circle cx="8" cy="8" r="7" 
                        stroke="#333" 
                        stroke-width="1" 
                        fill="${color}" 
                        fill-opacity="0.9"
                    />
                </svg>
            `,
            iconSize: [16, 16],
            iconAnchor: [8, 8]
        });
    }

    // Add socket connection listener
    socket.on('connect', () => {
        console.log('Connected to server');
    });

    // Update your Socket.IO bridge_update handler
    socket.on('bridge_update', (updatedBridge) => {
        console.log('Bridge update received:', updatedBridge);
        
        // Get the marker for this bridge
        const marker = binToMarker[updatedBridge.bin];
        if (!marker) return;

        // Update the bridge data stored on the marker
        marker.bridgeData = updatedBridge;

        // Update marker position if lat/lon changed
        if (updatedBridge.lat && updatedBridge.lon) {
            marker.setLatLng([updatedBridge.lat, updatedBridge.lon]);
        }

        // Update marker color based on status
        const inspected = updatedBridge.completed && updatedBridge.completed.trim() !== "";
        const scheduled = !inspected && updatedBridge.week && 
            updatedBridge.week.trim().toLowerCase() !== "unscheduled";
        
        let iconColor = inspected ? "green" : scheduled ? "orange" : "blue";
        marker.setIcon(createMarkerIcon(iconColor));

        // Create new popup content
        const popup = `
            <span style="font-size:16px;"><b><u>${updatedBridge.bin}</u></b></span><br>
            <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${updatedBridge.lat},${updatedBridge.lon}" target="_blank" style="color:#1976d2;">${updatedBridge.lat.toFixed(4)}, ${updatedBridge.lon.toFixed(4)}</a><br>
            <b>New Standards:</b> ${updatedBridge.stds}<br>
            <b>Due Date:</b> ${updatedBridge.due}/25<br>
            <b>Active Flags:</b> ${updatedBridge.flags}<br>
            <b>Load Posting:</b> ${updatedBridge.posting_label}<br>
            <a href="#" onclick="showModal('${updatedBridge.bin}'); return false;">See moreâ€¦</a>
        `;

        // Update the popup content
        if (marker.getPopup()) {
            marker.getPopup().setContent(popup);
        }

        // Update sidebar if this bridge is currently shown
        const sidebar = document.getElementById("bridgeSidebar");
        if (sidebar.classList.contains("open")) {
            const currentBin = document.querySelector("#modal-body")?.getAttribute("data-bin");
            if (currentBin === updatedBridge.bin) {
                showModal(updatedBridge.bin);  // Re-fetch and display updated data
            }
        }
    });

    // Helper function to determine bridge status
    function getStatus(bridge) {
        const inspected = bridge.completed && bridge.completed.trim() !== "";
        const scheduled = !inspected && 
            bridge.week && 
            bridge.week.trim().toLowerCase() !== "unscheduled";
        return inspected ? "Inspected" : scheduled ? "Scheduled" : "Assigned";
    }

    // Helper function to get marker color based on status
    function getMarkerColor(status) {
        switch (status) {
            case "Inspected": return "green";
            case "Scheduled": return "orange";
            default: return "blue";
        }
    }
    
    // Initialize filter state object
    const filters = {
        flags: new Set(),
        posting: new Set(),
        access: new Set(),
        week: new Set(),
        due_month: new Set(),
        status: new Set(['Assigned', 'Scheduled', 'Inspected']) // Initialize with all statuses
    };

    // Helper function to get bridge status
    function getBridgeStatus(bridge) {
        const inspected = bridge.completed && bridge.completed.trim() !== "";
        const scheduled = !inspected && 
            bridge.week && 
            bridge.week.trim().toLowerCase() !== "unscheduled";
        return inspected ? "Inspected" : scheduled ? "Scheduled" : "Assigned";
    }

    // Helper functions for sorting
    function sortMonths(monthSet) {
        const monthOrder = [
            "January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];
        return Array.from(monthSet).sort(
            (a, b) => monthOrder.indexOf(a) - monthOrder.indexOf(b)
        );
    }

    function sortWeeks(weekSet) {
        return Array.from(weekSet).sort((a, b) => {
            const dateA = new Date("2025/" + a.replace("Week of ", ""));
            const dateB = new Date("2025/" + b.replace("Week of ", ""));
            return dateA - dateB;
        });
    }

    function pushUnscheduledToEnd(arr) {
        return arr.filter(v => v !== "Unscheduled").concat(
            arr.includes("Unscheduled") ? ["Unscheduled"] : []
        );
    }

    // Function to create filter checkboxes
    function createFilterCheckboxes() {
        const unique = {
            flags: new Set(),
            posting: new Set(),
            access: new Set(),
            week: new Set(),
            due_month: new Set()
        };

        // Gather unique values
        bridgeData.forEach(b => {
            unique.flags.add(b.flags);
            unique.posting.add(b.posting);
            unique.access.add(b.access);
            unique.week.add(b.week);
            unique.due_month.add(b.due_month);
        });

        // Create checkboxes for each filter group
        function createCheckbox(containerId, groupKey, values) {
            const container = document.getElementById(containerId);
            values.forEach(val => {
                const safeId = `${containerId}-${val.replace(/\W+/g, "_")}`;
                const label = document.createElement("label");
                label.innerHTML = `
                    <input type="checkbox" 
                        id="${safeId}" 
                        value="${val}" 
                        data-group="${groupKey}" 
                        checked> ${val}`;
                container.appendChild(label);
                filters[groupKey].add(val);
            });
        }

        // Initialize each filter group
        createCheckbox("filter-flags", "flags", Array.from(unique.flags));
        createCheckbox("filter-posting", "posting", Array.from(unique.posting));
        createCheckbox("filter-access", "access", Array.from(unique.access));
        createCheckbox("filter-week-items", "week", 
            pushUnscheduledToEnd(sortWeeks(unique.week)));
        createCheckbox("filter-due_month-items", "due_month", 
            sortMonths(unique.due_month));
    }

    // Function to check if a bridge passes all current filters
    function passesFilters(bridge) {
        const status = getStatus(bridge);
        if (!filters.status.has(status)) return false;

        return (
            filters.flags.has(bridge.flags) &&
            filters.posting.has(bridge.posting) &&
            filters.access.has(bridge.access) &&
            filters.week.has(bridge.week) &&
            filters.due_month.has(bridge.due_month)
        );
    }

    // Update markers based on current filters
    function updateMarkers() {
        if (isDueSoonActive) return; // Don't update if Due Soon is active

        let visibleCount = 0;
        allMarkers.forEach(({ marker, data }) => {
            if (passesFilters(data)) {
                if (!map.hasLayer(marker)) map.addLayer(marker);
                visibleCount++;
            } else {
                if (map.hasLayer(marker)) map.removeLayer(marker);
            }
        });

        document.getElementById("visibleCounter").textContent = 
            `Visible Bridges: ${visibleCount}`;
    }

    document.addEventListener("DOMContentLoaded", function () {
        // Initialize map first
        map = L.map('map').setView([43.0, -75.0], 7);
        
        // Initialize markers layer group after map is created
        markersGroup = L.layerGroup().addTo(map);

        map.on('zoomend', updateBinLabelVisibility);
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Panel toggle setup
        const filterToggleBtn = document.getElementById("filterToggleBtn");
        const dueSoonToggleBtn = document.getElementById("dueSoonToggleBtn");
        const filterPanel = document.getElementById("filterPanel");
        const dueSoonPanel = document.getElementById("dueSoonPanel");

        // Filter panel toggle
        filterToggleBtn.addEventListener("click", () => {
            if (isDueSoonActive) {
                alert("Please clear 'Due Soon' filter before using other filters");
                return;
            }

            const isVisible = filterPanel.style.display === "block";
            filterPanel.style.display = isVisible ? "none" : "block";
            dueSoonPanel.style.display = "none";
            
            filterToggleBtn.textContent = isVisible ? "ðŸ”½ Filters" : "ðŸ”¼ Filters";
            dueSoonToggleBtn.textContent = "ðŸ”½ Due Soon";
        });

        // Due Soon panel toggle
        dueSoonToggleBtn.addEventListener("click", () => {
            const isVisible = dueSoonPanel.style.display === "block";
            dueSoonPanel.style.display = isVisible ? "none" : "block";
            filterPanel.style.display = "none";
            
            dueSoonToggleBtn.textContent = isVisible ? "ðŸ”½ Due Soon" : "ðŸ”¼ Due Soon";
            filterToggleBtn.textContent = "ðŸ”½ Filters";
        });

        // Collapse toggles for filter groups
        document.querySelectorAll('.collapse-toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                const targetId = btn.dataset.target;
                const content = document.getElementById(targetId);
                if (!content) {
                    console.error(`Target content not found: ${targetId}`);
                    return;
                }
                
                content.classList.toggle('collapsed');
                btn.textContent = content.classList.contains('collapsed') ? '+' : 'âˆ’';
            });
        });

        // Due Soon Apply button
        document.getElementById("applyDueSoon").addEventListener("click", () => {
            isDueSoonActive = true;
            const days = parseInt(document.getElementById("dueSoonDays").value, 10);
            const today = new Date();

            // Hide all markers first
            allMarkers.forEach(({ marker }) => {
                map.removeLayer(marker);
            });

            // Show only bridges due within the specified days
            allMarkers.forEach(({ marker, data }) => {
                try {
                    const inspected = data.completed && data.completed.trim() !== "";
                    if (inspected) return; // Skip inspected bridges

                    const dueParts = data.due.split("/");
                    const dueDate = new Date(2025, parseInt(dueParts[0]) - 1, parseInt(dueParts[1]));
                    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));

                    if (diffDays >= 0 && diffDays <= days) {
                        map.addLayer(marker);
                    }
                } catch (error) {
                    console.warn(`Error processing due date for bridge ${data.bin}:`, error);
                }
            });

            // Update visible counter
            const visibleCount = allMarkers.filter(({ marker }) => map.hasLayer(marker)).length;
            document.getElementById("visibleCounter").textContent = 
                `Visible Bridges: ${visibleCount}`;

            // Close the filters panel if it's open
            filterPanel.style.display = "none";
            filterToggleBtn.textContent = "ðŸ”½ Filters";

            updateBinLabelVisibility();
        });

        // Due Soon Clear button
        document.getElementById("clearDueSoon").addEventListener("click", () => {
            isDueSoonActive = false;
            
            // Reset to normal filter view
            updateMarkers();
            updateBinLabelVisibility();

            // Close the due soon panel
            dueSoonPanel.style.display = "none";
            dueSoonToggleBtn.textContent = "ðŸ”½ Due Soon";
        });

                
        fetch('/api/bridges')
            .then(response => {
                if (!response.ok) {
                    return response.json().then(err => Promise.reject(err));
                }
                return response.json();
            })
            .then(data => {
                console.log("Received bridge data:", data);
                
                // Store the bridge data globally
                bridgeData = Array.isArray(data) ? data : [];
                
                // Initialize filters after we have the data
                createFilterCheckboxes();
                
                // Process each bridge
                bridgeData.forEach(bridge => {
                    if (!bridge.lat || !bridge.lon) {
                        console.warn(`Bridge ${bridge.bin} missing coordinates`);
                        return;
                    }

                    // Create marker using L.marker instead of L.circleMarker
                    const marker = L.marker([bridge.lat, bridge.lon], {
                        icon: createMarkerIcon(getMarkerColor(bridge))
                    }).addTo(map);

                    // Add popup
                    marker.bindPopup(`
                        <span style="font-size:16px;"><b><u>${bridge.bin}</u></b></span><br>
                        <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${bridge.lat},${bridge.lon}" target="_blank" style="color:#1976d2;">${bridge.lat.toFixed(4)}, ${bridge.lon.toFixed(4)}</a><br>
                        <b>New Standards:</b> ${bridge.stds}<br>
                        <b>Due Date:</b> ${bridge.due}/25<br>
                        <b>Active Flags:</b> ${bridge.flags}<br>
                        <b>Load Posting:</b> ${bridge.posting_label}<br>
                        <a href="#" onclick="showModal('${bridge.bin}'); return false;">See moreâ€¦</a>
                    `);

                    binToMarker[bridge.bin] = marker;
                    marker.bridgeData = bridge;

                    // Add label
                    const label = L.marker([bridge.lat, bridge.lon], {
                        icon: L.divIcon({
                            className: 'bin-label',
                            html: bridge.bin,
                            iconSize: null
                        }),
                        interactive: false
                    }).addTo(map);

                    allMarkers.push({ marker, data: bridge });
                });

                // Set up filter checkbox event listeners
                document.querySelectorAll("#filterPanel input[type=checkbox]").forEach(cb => {
                    cb.addEventListener("change", () => {
                        const group = cb.dataset.group;
                        const val = cb.value;
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Initialize status filter checkboxes
                document.querySelectorAll('.filter-checkbox.status').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const val = cb.value;
                        const group = 'status'; // explicitly set group for status checkboxes
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Modify the existing filter checkbox event listener to exclude status checkboxes
                document.querySelectorAll("#filterPanel input[type=checkbox]:not(.status)").forEach(cb => {
                    cb.addEventListener("change", () => {
                        const group = cb.dataset.group;
                        const val = cb.value;
                        
                        if (cb.checked) {
                            filters[group].add(val);
                        } else {
                            filters[group].delete(val);
                        }
                        
                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Set up All/None toggle buttons
                document.querySelectorAll(".toggle-btn").forEach(btn => {
                    btn.addEventListener("click", () => {
                        const group = btn.dataset.group;
                        const checkboxes = document.querySelectorAll(
                            `#filter-${group}-content input[type=checkbox]`
                        );
                        
                        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                        filters[group].clear();  // reset group

                        checkboxes.forEach(cb => {
                            cb.checked = !allChecked;
                            if (!allChecked) {
                                filters[group].add(cb.value);
                            }
                        });

                        updateMarkers();
                        updateBinLabelVisibility();
                    });
                });

                // Replace the existing searchbar code inside the fetch .then() callback
                const searchInput = document.getElementById("binSearchInput");
                const searchDatalist = document.getElementById("binList");

                // Clear any existing options
                searchDatalist.innerHTML = "";

                // Add input event for live filtering
                searchInput.addEventListener("input", function() {
                    const value = this.value.trim().toUpperCase();
                    searchDatalist.innerHTML = "";  // Clear existing options

                    if (value.length >= 3) {
                        const matches = bridgeData
                            .filter(b => b.bin.toUpperCase().includes(value))
                            .slice(0, 50);  // Limit to first 50 matches

                        matches.forEach(bridge => {
                            const option = document.createElement("option");
                            option.value = bridge.bin;
                            searchDatalist.appendChild(option);
                        });
                    }
                });

                // Keep the existing keypress handler for Enter key
                searchInput.addEventListener("keypress", function(e) {
                    if (e.key === "Enter") {
                        const value = this.value.trim().toUpperCase();
                        const bridge = bridgeData.find(b => b.bin.toUpperCase() === value);
                        
                        if (bridge) {
                            map.setView([bridge.lat, bridge.lon], 16);
                            const marker = binToMarker[bridge.bin];
                            if (marker) {
                                marker.openPopup();
                            }
                        } else {
                            alert("Bridge not found");
                        }
                        
                        this.value = "";
                    }
                });


                updateLabelVisibility();
                updateMarkers();
            })
            .catch(error => {
                console.error('Error fetching bridge data:', error);
            });

        function getMarkerColor(bridge) {
            const inspected = bridge.completed && bridge.completed.trim() !== "";
            const scheduled = !inspected && bridge.week && 
                bridge.week.trim() !== "" && 
                bridge.week.trim().toLowerCase() !== "unscheduled";
            
            return inspected ? "green" : scheduled ? "orange" : "blue";
        }
            

        const socket = io();
        
        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('bridge_update', (updatedBridge) => {
            console.log('Bridge update received:', updatedBridge);
            
            // Get the marker for this bridge
            const marker = binToMarker[updatedBridge.bin];
            if (!marker) return;

            // Update the bridge data stored on the marker
            marker.bridgeData = updatedBridge;

            // Update marker position if lat/lon changed
            if (updatedBridge.lat && updatedBridge.lon) {
                marker.setLatLng([updatedBridge.lat, updatedBridge.lon]);
            }

            // Update marker color based on status
            const inspected = updatedBridge.completed && updatedBridge.completed.trim() !== "";
            const scheduled = !inspected && updatedBridge.week && 
                updatedBridge.week.trim().toLowerCase() !== "unscheduled";
            
            let iconColor = inspected ? "green" : scheduled ? "orange" : "blue";
            marker.setIcon(createMarkerIcon(iconColor));

            // Create new popup content
            const popup = `
                <span style="font-size:16px;"><b><u>${updatedBridge.bin}</u></b></span><br>
                <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${updatedBridge.lat},${updatedBridge.lon}" target="_blank" style="color:#1976d2;">${updatedBridge.lat.toFixed(4)}, ${updatedBridge.lon.toFixed(4)}</a><br>
                <b>New Standards:</b> ${updatedBridge.stds}<br>
                <b>Due Date:</b> ${updatedBridge.due}/25<br>
                <b>Active Flags:</b> ${updatedBridge.flags}<br>
                <b>Load Posting:</b> ${updatedBridge.posting_label}<br>
                <a href="#" onclick="showModal('${updatedBridge.bin}'); return false;">See moreâ€¦</a>
            `;

            // Update the popup content
            if (marker.getPopup()) {
                marker.getPopup().setContent(popup);
            }

            // Update sidebar if this bridge is currently shown
            const sidebar = document.getElementById("bridgeSidebar");
            if (sidebar.classList.contains("open")) {
                const currentBin = document.querySelector("#modal-body")?.getAttribute("data-bin");
                if (currentBin === updatedBridge.bin) {
                    showModal(updatedBridge.bin);  // Re-fetch and display updated data
                }
            }
        });

    }); // Close DOMContentLoaded event listener

    // Update the updateLabelVisibility function to use the global map
    function updateLabelVisibility() {
        if (!map) return; // Add safety check
        const currentZoom = map.getZoom();
        const showLabels = currentZoom >= 12;

        document.querySelectorAll('.bin-label').forEach(label => {
            label.style.display = showLabels ? 'block' : 'none';
        });
    }

    // Add this to your JavaScript section
    function showModal(bin) {
        fetch(`/api/bridges/${bin}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(bridge => {
                const modal = document.getElementById('bridgeSidebar');
                const overlay = document.getElementById('bridgeSidebarOverlay');
                const modalBody = document.getElementById('modal-body');
                
                modalBody.setAttribute('data-bin', bridge.bin);
                
                const content = `
                    <h2>Bridge ${bridge.bin}</h2>
                    <p><strong>Region:</strong> ${bridge.region}</p>
                    <p><strong>County:</strong> ${bridge.county}</p>
                    <p><strong>Due Date:</strong> ${bridge.due}/25</p>
                    <p><strong>Completed:</strong> ${bridge.completed || 'Not completed'}</p>
                    <p><strong>Week:</strong> ${bridge.week}</p>
                    <p><strong>Flags:</strong> ${bridge.flags}</p>
                    <p><strong>Flag Info:</strong> ${bridge.flags_info}</p>
                    <p><strong>Posting:</strong> ${bridge.posting}</p>
                    <p><strong>Access:</strong> ${bridge.access}</p>
                    <p><strong>Access Info:</strong> ${bridge.access_info}</p>
                    <p><strong>Special Equipment:</strong> ${bridge.spe}</p>
                    <p><strong>Standards:</strong> ${bridge.stds}</p>
                    <p><strong>Field Time:</strong> ${bridge.field_time}</p>
                `;
                
                modalBody.innerHTML = content;
                modal.classList.add('open');
                overlay.style.display = 'block';
            })
            .catch(error => {
                console.error('Error fetching bridge details:', error);
            });
    }

    // Add this with your other JavaScript functions
    function closeModal() {
        const sidebar = document.getElementById('bridgeSidebar');
        const overlay = document.getElementById('bridgeSidebarOverlay');
        sidebar.classList.remove('open');
        overlay.style.display = 'none';
    }

    // Add this with your other Socket.IO listeners after socket initialization
    socket.on('new_bridge', (newBridge) => {
        console.log('New bridge received:', newBridge);
        
        // Create marker with proper icon
        const marker = L.marker([newBridge.lat, newBridge.lon], {
            icon: createMarkerIcon(getMarkerColor(newBridge))
        }).addTo(map);

        // Add popup
        marker.bindPopup(`
            <span style="font-size:16px;"><b><u>${newBridge.bin}</u></b></span><br>
            <b>Coordinates:</b> <a href="https://www.google.com/maps/dir/?api=1&destination=${newBridge.lat},${newBridge.lon}" target="_blank" style="color:#1976d2;">${newBridge.lat.toFixed(4)}, ${newBridge.lon.toFixed(4)}</a><br>
            <b>New Standards:</b> ${newBridge.stds}<br>
            <b>Due Date:</b> ${newBridge.due}/25<br>
            <b>Active Flags:</b> ${newBridge.flags}<br>
            <b>Load Posting:</b> ${newBridge.posting_label}<br>
            <a href="#" onclick="showModal('${newBridge.bin}'); return false;">See moreâ€¦</a>
        `);

        // Add the marker to the layer group
        markersGroup.addLayer(marker);

        // Store the marker reference
        binToMarker[newBridge.bin] = marker;
        marker.bridgeData = newBridge;

        // Add label
        const label = L.marker([newBridge.lat, newBridge.lon], {
            icon: L.divIcon({
                className: 'bin-label',
                html: newBridge.bin,
                iconSize: null
            }),
            interactive: false
        }).addTo(map);

        // Add to allMarkers array for tracking
        allMarkers.push({ marker, data: newBridge });

        // Update markers count
        updateMarkers();
    });

    // Add this with your other Socket.IO listeners
    socket.on('bridge_deleted', (data) => {
        console.log('Bridge deleted:', data.bin);
        
        // Get the marker for this bridge
        const marker = binToMarker[data.bin];
        if (!marker) return;

        // Remove the marker from the map
        map.removeLayer(marker);
        
        // Remove from binToMarker object
        delete binToMarker[data.bin];
        
        // Remove from allMarkers array
        const markerIndex = allMarkers.findIndex(m => m.data.bin === data.bin);
        if (markerIndex !== -1) {
            allMarkers.splice(markerIndex, 1);
        }
        
        // Update markers count
        updateMarkers();
    });

    // Add this function with your other utility functions
    function updateBinLabelVisibility() {
        if (!map) return;
        const zoom = map.getZoom();
        const showLabels = zoom >= 11;

        // Update visibility of all bin labels
        document.querySelectorAll('.bin-label').forEach(label => {
            const parentMarker = label._marker; // Get the associated marker
            if (parentMarker && map.hasLayer(parentMarker)) {
                label.style.display = showLabels ? 'block' : 'none';
            } else {
                label.style.display = 'none';
            }
        });
    }



    </script>

</body>
</html>
